const conteneur = document.querySelector("#game-container");
const gameover = createGameElement("div", "Start Game", ["game-over"]);
const ball = createGameElement("div", "", ["ball"]);
const paddle = createGameElement("div", "", ["paddle"]);

let dimensionRec = conteneur.getBoundingClientRect();

const keyMap = {
  ArrowLeft: "left",
  ArrowRight: "right",
};

const player = {
  gameover: true,
  score: 0,
  lives: 3,
  ballDir: { x: 5, y: 5 },
};

// Functions
function createGameElement(elementType, textContent = "", classes = []) {
  const element = document.createElement(elementType);
  element.textContent = textContent;
  element.classList.add(...classes);
  return element;
}

function startGame() {
  if (player.gameover) {
    player.gameover = false;
    gameover.style.display = "none";
    player.score = 0;
    player.lives = 3;
    ball.style.display = "block";
    player.ballDir = { x: 5, y: -5 };
    setupBricks(30);
    scoreUpdater();
    window.requestAnimationFrame(moveBall);
  }
}

// Reste du code...

// Event Listeners
document.addEventListener("keydown", (event) => {
  const key = keyMap[event.key];
  if (key === "left" || key === "right") {
    paddleMovement[key] = event.type === "keydown";
  } else if (event.code === "Space") {
    startGame();
  }
});

conteneur.addEventListener("click", () => {
  if (player.gameover) {
    startGame();
  }
});

// Additional Functions...

// Additional Functions

function setupBricks(nbr) {
    let rang = { x: 10, y: 50 };
  
    for (let x = 0; x < nbr; x++) {
      if (rang.x > dimensionRec.width - 100) {
        rang.y += 50;
        rang.x = 10;
      }
      createBrick(rang);
      rang.x += 100;
    }
  }
  
  function createBrick(pos) {
    const brick = createGameElement("div", "", ["brick"]);
    brick.style.left = pos.x + "px";
    brick.style.top = pos.y + "px";
    conteneur.appendChild(brick);
  }
  
  function collision(elem1, elem2) {
    const elem1Rect = elem1.getBoundingClientRect();
    const elem2Rect = elem2.getBoundingClientRect();
  
    return !(
      elem1Rect.right < elem2Rect.left ||
      elem1Rect.left > elem2Rect.right ||
      elem1Rect.bottom < elem2Rect.top ||
      elem1Rect.top > elem2Rect.bottom
    );
  }
  
  function scoreUpdater() {
    document.querySelector(".score").textContent = player.score;
    document.querySelector(".lives").textContent = player.lives;
  }
  
  function moveBall() {
    const posBall = { x: ball.offsetLeft, y: ball.offsetTop };
    const ballWidth = 20;
    const ballHeight = 20;
  
    if (posBall.y < 0) {
      player.ballDir.y *= -1;
    }
    if (posBall.x > dimensionRec.width - ballWidth || posBall.x < 0) {
      player.ballDir.x *= -1;
    }
    if (posBall.y > dimensionRec.height - ballHeight) {
      handleBallOutOfBounds();
      return;
    }
  
    handlePaddleCollision(posBall);
    handleBrickCollision(posBall);
  
    posBall.x += player.ballDir.x;
    posBall.y += player.ballDir.y;
  
    ball.style.left = posBall.x + "px";
    ball.style.top = posBall.y + "px";
  
    const position = paddle.offsetLeft;
    const paddleWidth = paddle.offsetWidth;
    const paddleMoveSpeed = 10;
  
    if (paddleMovement.left && position > 0) {
      paddle.style.left = Math.max(0, position - paddleMoveSpeed) + "px";
    }
    if (paddleMovement.right && position < dimensionRec.width - paddleWidth) {
      paddle.style.left = Math.min(
        dimensionRec.width - paddleWidth,
        position + paddleMoveSpeed
      ) + "px";
    }
  
    if (!player.gameover) {
      window.requestAnimationFrame(moveBall);
    } else {
      gameover.style.display = "block";
    }
  }
  
  function handleBallOutOfBounds() {
    player.lives--;
    if (player.lives <= 0) {
      player.gameover = true;
      gameover.style.display = "block";
    } else {
      resetBallPosition();
      setTimeout(() => {
        ball.style.display = "block";
        window.requestAnimationFrame(moveBall);
      }, 1000);
    }
  }
  
  function resetBallPosition() {
    ball.style.display = "none";
    const posBall = { x: dimensionRec.width / 2, y: dimensionRec.height / 2 };
    ball.style.left = posBall.x + "px";
    ball.style.top = posBall.y + "px";
    player.ballDir = { x: 5, y: -5 };
  }
  
  function handlePaddleCollision(posBall) {
    if (collision(paddle, ball)) {
      const temp = (posBall.x - paddle.offsetLeft - paddle.offsetWidth / 2) / 10;
      player.ballDir.x = temp;
      player.ballDir.y *= -1;
    }
  }
  
  function handleBrickCollision(posBall) {
    const bricks = document.querySelectorAll(".brick");
    bricks.forEach((brick) => {
      if (collision(brick, ball)) {
        player.ballDir.y *= -1;
        brick.parentNode.removeChild(brick);
        player.score += 10;
        scoreUpdater();
      }
    });
  }
  
  // ... (Le code précédent est inchangé)

// Event Listeners (suite)

document.addEventListener("keydown", (event) => {
    const key = keyMap[event.key];
    if (key === "left" || key === "right") {
      paddleMovement[key] = event.type === "keydown";
    }
  });
  
  document.addEventListener("keyup", (event) => {
    const key = keyMap[event.key];
    if (key === "left" || key === "right") {
      paddleMovement[key] = event.type === "keydown";
    }
  });
  
  // Call to start the game function
  startGame();
  
  // Function to restart the game
  function restartGame() {
    player.gameover = false;
    gameover.style.display = "none";
    ball.style.display = "block";
    player.score = 0;
    player.lives = 3;
    player.ballDir = { x: 5, y: -5 };
    resetBallPosition();
    setupBricks(30);
    scoreUpdater();
    window.requestAnimationFrame(moveBall);
  }
// ... (Le code précédent est inchangé)

// Event Listener pour redémarrer le jeu lors du clic sur le conteneur après la fin d'une partie
conteneur.addEventListener("click", () => {
    if (player.gameover) {
      restartGame();
    }
  });
  

  
  // Fonction pour réinitialiser la position de la balle
  function resetBallPosition() {
    ball.style.display = "none";
    const posBall = { x: dimensionRec.width / 2, y: dimensionRec.height / 2 };
    ball.style.left = posBall.x + "px";
    ball.style.top = posBall.y + "px";
  }
  
  // ... (Le reste du code reste inchangé)
    